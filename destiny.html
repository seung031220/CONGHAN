<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìš´ëª…ì˜ ê²Œì„ | ì½©í•œìª½</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
:root {
  --bg: #1a0f0f;
  --bg-gradient: radial-gradient(120% 120% at 10% 10%, #2d1515 0%, #1a0f0f 40%, #0d0808 100%);
  --surface: rgba(255, 255, 255, 0.08);
  --surface-strong: rgba(255, 255, 255, 0.12);
  --ink: #f5e6e6;
  --muted: #a08080;
  --brand: #c0392b;
  --brand-strong: #922b21;
  --border: rgba(160, 80, 80, 0.2);
  --shadow: 0 30px 80px rgba(80, 20, 20, 0.35);
  --radius-lg: 32px;
  --radius-md: 20px;
}

* { box-sizing: border-box; }

body {
  margin: 0;
  font-family: 'Noto Sans KR', sans-serif;
  background: var(--bg);
  background-image: var(--bg-gradient);
  color: var(--ink);
  min-height: 100vh;
  padding: 16px;
  position: relative;
  overflow-x: hidden;
}

body::before,
body::after {
  content: "";
  position: fixed;
  width: 280px;
  height: 280px;
  background: linear-gradient(140deg, rgba(192, 57, 43, 0.25), rgba(146, 43, 33, 0.2));
  filter: blur(100px);
  z-index: -2;
  transform: translate(-50%, -50%);
}
body::before { top: 16%; left: 10%; }
body::after { bottom: -8%; right: -6%; }

.shell {
  max-width: 560px;
  margin: 0 auto;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  padding: 24px 0;
  text-align: center;
}

a.back {
  color: var(--muted);
  text-decoration: none;
  font-size: 0.9rem;
  display: inline-block;
  margin-bottom: 24px;
}
a.back:hover { color: var(--ink); }

.panel {
  background: var(--surface-strong);
  border-radius: var(--radius-lg);
  padding: 24px;
  border: 1px solid var(--border);
  box-shadow: var(--shadow);
  margin-bottom: 24px;
}
.panel h1 { font-size: 1.5rem; margin: 0 0 24px; font-weight: 700; }

.score-board {
  display: flex;
  justify-content: center;
  gap: 32px;
  margin-bottom: 32px;
  font-size: 1.5rem;
  font-weight: 800;
}
.score-board span { font-size: 2.4rem; font-weight: 900; }
.score-board .my-score span { color: #60a5fa; }
.score-board .opp-score span { color: #f87171; }

.choices { display: flex; justify-content: center; gap: 16px; flex-wrap: wrap; margin-bottom: 24px; }
.choice-btn {
  padding: 18px 22px;
  border-radius: 16px;
  border: 2px solid var(--border);
  background: var(--surface);
  color: var(--ink);
  font-size: 1.05rem;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  min-width: 100px;
  display: inline-flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
}
.choice-btn .choice-emoji {
  font-size: 3rem;
  line-height: 1;
}
.choice-btn:hover {
  border-color: var(--brand);
  background: var(--surface-strong);
}
.choice-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  pointer-events: none;
}

.choice-btn.rt-choice {
  pointer-events: auto;
}

/* Player2 ë²„íŠ¼ ê°•ì œ í‘œì‹œë¥¼ ìœ„í•œ CSS */
#rtChoices.player2-active {
  display: flex !important;
  visibility: visible !important;
  opacity: 1 !important;
  height: auto !important;
  width: auto !important;
  position: relative !important;
}

#rtChoices.player2-active .rt-choice {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  pointer-events: auto !important;
  cursor: pointer !important;
}

.round-info { font-size: 1rem; color: var(--muted); margin-bottom: 16px; }
.result-msg { font-size: 1.25rem; font-weight: 700; margin: 16px 0; min-height: 28px; }

.final-panel {
  display: none;
  background: var(--surface-strong);
  border-radius: var(--radius-lg);
  padding: 32px;
  border: 1px solid var(--border);
  margin-top: 24px;
  position: relative;
  overflow: hidden;
}
.final-panel.visible { display: block; }
.final-panel h2 { margin: 0 0 16px; font-size: 1.4rem; }
.final-panel.win h2 { color: #4ade80; }
.final-panel.lose h2 { color: #f87171; }
.final-copy {
  font-size: 1rem;
  color: var(--ink);
  line-height: 1.6;
  margin-bottom: 16px;
}
.final-copy .line { display: block; }
.final-copy .emoji { margin-left: 6px; }

.btn-main {
  display: inline-block;
  padding: 14px 28px;
  border-radius: 12px;
  background: linear-gradient(130deg, var(--brand-strong), var(--brand));
  color: #fff;
  text-decoration: none;
  font-weight: 700;
  margin-top: 16px;
}
.btn-main:hover { opacity: 0.95; }

.confetti {
  position: absolute;
  inset: 0;
  pointer-events: none;
  overflow: hidden;
}
.confetti span {
  position: absolute;
  top: -10%;
  width: 8px;
  height: 14px;
  border-radius: 4px;
  opacity: 0.9;
  animation: confetti-fall 2.8s linear infinite;
}
@keyframes confetti-fall {
  0% { transform: translateY(-20px) rotate(0deg); }
  100% { transform: translateY(520px) rotate(360deg); }
}

.swipe-card {
  background: rgba(0, 0, 0, 0.2);
  border: 1px solid var(--border);
  border-radius: 20px;
  padding: 18px;
  margin-top: 18px;
}
.swipe-title {
  font-size: 1rem;
  color: var(--muted);
  margin-bottom: 12px;
}
.swipe-track {
  position: relative;
  height: 54px;
  border-radius: 30px;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid var(--border);
  overflow: hidden;
}
.swipe-text {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  color: var(--ink);
  letter-spacing: 0.2px;
}
.swipe-handle {
  position: absolute;
  top: 4px;
  left: 4px;
  width: 46px;
  height: 46px;
  border-radius: 50%;
  background: linear-gradient(130deg, #f59e0b, #f97316);
  box-shadow: 0 10px 25px rgba(0,0,0,0.25);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-size: 1.1rem;
  user-select: none;
  touch-action: none;
}

.realtime-status {
  font-size: 1.1rem;
  color: var(--muted);
  margin: 24px 0;
  min-height: 1.5em;
}
.realtime-status.found {
  color: var(--brand);
  font-weight: 700;
}

.status-toast {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(192, 57, 43, 0.95);
  color: #fff;
  padding: 12px 18px;
  border-radius: 12px;
  font-weight: 800;
  box-shadow: var(--shadow);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
  z-index: 20;
}
.status-toast.show { opacity: 1; }

.realtime-waiting {
  color: #f87171;
  font-size: 1.4rem;
  font-weight: 900;
  margin-top: 16px;
  padding: 12px 16px;
  border-radius: 14px;
  border: 1px solid rgba(248, 113, 113, 0.6);
  background: rgba(248, 113, 113, 0.12);
  animation: alert-pulse 1.1s ease-in-out infinite;
}
@keyframes alert-pulse {
  0% { box-shadow: 0 0 0 rgba(248,113,113,0.2); }
  50% { box-shadow: 0 0 18px rgba(248,113,113,0.65); }
  100% { box-shadow: 0 0 0 rgba(248,113,113,0.2); }
}

/* ìº¡ìŠ ì»¨ì…‰ ì•ˆë‚´ ë¬¸êµ¬ */
.game-guide {
  margin: 12px auto 14px;
  max-width: 520px;
  padding: 12px 14px;
  border-radius: 16px;
  border: 1px solid var(--border);
  background: rgba(255, 255, 255, 0.06);
  color: var(--ink);
  line-height: 1.55;
  font-weight: 600;
  font-size: 0.95rem;
}
.game-guide .hint {
  color: var(--muted);
  font-weight: 700;
}

/* ìº¡ìŠ UI */
.capsule-area {
  display: none;
  justify-content: center;
  gap: 14px;
  margin: 14px 0 18px;
  flex-wrap: wrap;
}
.capsule-card {
  width: 210px;
  padding: 14px 14px 16px;
  border-radius: 20px;
  border: 1px solid var(--border);
  background: rgba(255, 255, 255, 0.06);
}
.capsule-title {
  font-size: 0.95rem;
  font-weight: 900;
  color: var(--ink);
  margin-bottom: 10px;
}
.capsule {
  width: 100%;
  height: 74px;
  border-radius: 999px;
  position: relative;
  overflow: hidden;
  border: 2px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.16);
  box-shadow: 0 18px 40px rgba(0,0,0,0.25);
}
.capsule .half {
  position: absolute;
  top: 0;
  width: 50%;
  height: 100%;
  background: linear-gradient(140deg, rgba(255,255,255,0.16), rgba(255,255,255,0.08));
  border: 1px solid rgba(255,255,255,0.12);
  backdrop-filter: blur(6px);
}
.capsule .half.left { left: 0; border-right: none; }
.capsule .half.right { right: 0; border-left: none; }
.capsule .content {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2.2rem;
  font-weight: 900;
  letter-spacing: 0.04em;
}
.capsule.sealed .content { filter: blur(0.2px); }
.capsule.open .half.left { transform: translateX(-58%); }
.capsule.open .half.right { transform: translateX(58%); }
.capsule .half { transition: transform 420ms cubic-bezier(.2,.8,.2,1); }
.capsule.reveal .half.left,
.capsule.reveal .half.right { transition: transform 520ms cubic-bezier(.12,.95,.2,1); }

@keyframes capsule-pop {
  0% { transform: translateY(0) scale(1); }
  35% { transform: translateY(-6px) scale(1.02); }
  100% { transform: translateY(0) scale(1); }
}
.capsule.pop { animation: capsule-pop 520ms ease; }

/* ìƒëŒ€ ê¸°ë‹¤ë¦¼ íŒì—… */
.waiting-popup {
  position: fixed;
  inset: 0;
  display: grid;
  place-items: center;
  background: rgba(0,0,0,0.55);
  backdrop-filter: blur(6px);
  z-index: 40;
}
.waiting-popup.hidden { display: none; }
.waiting-card {
  width: min(420px, calc(100vw - 32px));
  padding: 18px 18px 16px;
  border-radius: 22px;
  border: 1px solid var(--border);
  background: rgba(255,255,255,0.10);
  box-shadow: var(--shadow);
  text-align: center;
}
.waiting-title {
  font-size: 1.2rem;
  font-weight: 900;
  margin: 0 0 8px;
}
.waiting-sub {
  margin: 0;
  color: var(--muted);
  font-weight: 700;
  line-height: 1.5;
  font-size: 0.95rem;
}
.waiting-timer {
  margin-top: 12px;
  font-weight: 900;
  color: #fbbf24;
}
.waiting-timer span {
  font-size: 2.2rem;
  display: inline-block;
  min-width: 2ch;
}

/* ë¯¸ì„ íƒì: ì´ˆëŒ€í˜• ì¹´ìš´íŠ¸ë‹¤ìš´ ì˜¤ë²„ë ˆì´ */
.countdown-overlay {
  position: fixed;
  inset: 0;
  display: grid;
  place-items: center;
  background: rgba(0,0,0,0.25);
  z-index: 35;
  transition: background 200ms ease;
  pointer-events: none;
}
.countdown-overlay.hidden { display: none; }
.count-num {
  font-size: min(32vw, 220px);
  font-weight: 900;
  color: #fff;
  text-shadow: 0 18px 50px rgba(0,0,0,0.55);
  line-height: 1;
}

a.btn-again {
  display: inline-block;
  padding: 14px 28px;
  border-radius: 12px;
  background: linear-gradient(130deg, var(--brand-strong), var(--brand));
  color: #fff;
  text-decoration: none;
  font-weight: 700;
  margin-top: 16px;
}
a.btn-again:hover { opacity: 0.95; }

@media (min-width: 480px) {
  body { padding: 24px; }
  .shell { max-width: 520px; }
  .panel { padding: 28px; }
}
    </style>
</head>
<body>
    <div class="shell">
        <a href="index.html" class="back">â† ë©”ì¸ìœ¼ë¡œ</a>
        <div class="panel">
            <h1 style="margin-bottom: 6px; font-size: 2.2rem;">ì½©í•œìª½</h1>
            <div style="color: var(--muted); font-weight: 700; margin-bottom: 18px;">ì½©í•œìª½ì„ ê±´ ìš´ëª…ì˜ ê²Œì„</div>
            
            <div id="realtimeStatus" class="realtime-status">ìƒëŒ€ë¥¼ ì°¾ëŠ” ì¤‘...</div>
            
            <div class="score-board">
                <div class="my-score">ë‚˜: <span id="rtMyScore">0</span></div>
                <div class="opp-score">ìƒëŒ€: <span id="rtOppScore">0</span></div>
            </div>

            <div class="game-guide">
                <span class="hint">ìº¡ìŠì— ë‹´ì„ íŒ¨ë¥¼ ì„ íƒí•˜ì„¸ìš”.</span>
                ìƒëŒ€ëŠ” ìº¡ìŠì„ ì—´ê¸° ì „ì— ìì‹ ì˜ íŒ¨ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.
            </div>

            <div class="capsule-area" id="capsuleArea">
                <div class="capsule-card">
                    <div class="capsule-title">ë‚´ ìº¡ìŠ</div>
                    <div class="capsule sealed" id="myCapsule" aria-label="ë‚´ ìº¡ìŠ">
                        <div class="half left"></div>
                        <div class="half right"></div>
                        <div class="content" id="myCapsuleContent">â“</div>
                    </div>
                </div>
                <div class="capsule-card">
                    <div class="capsule-title">ìƒëŒ€ ìº¡ìŠ</div>
                    <div class="capsule sealed" id="oppCapsule" aria-label="ìƒëŒ€ ìº¡ìŠ">
                        <div class="half left"></div>
                        <div class="half right"></div>
                        <div class="content" id="oppCapsuleContent">â“</div>
                    </div>
                </div>
            </div>

            <div id="rtChoices" class="choices" style="display: none;">
                <button class="choice-btn rt-choice" data-choice="ê°€ìœ„">
                    <span class="choice-emoji">âœŒï¸</span>
                </button>
                <button class="choice-btn rt-choice" data-choice="ë°”ìœ„">
                    <span class="choice-emoji">âœŠ</span>
                </button>
                <button class="choice-btn rt-choice" data-choice="ë³´">
                    <span class="choice-emoji">ğŸ–ï¸</span>
                </button>
            </div>

            <div id="rtResultMsg" class="result-msg"></div>
            <div id="rtWaiting" class="realtime-waiting" style="display: none;">ìƒëŒ€ì˜ íŒ¨ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘</div>

            <div id="realtimeFinal" class="final-panel" style="display: none;">
                <div id="finalWin" style="display: none;">
                    <div class="confetti" id="confettiLayer"></div>
                    <h2>ì¶•í•˜í•´ìš”! ì´ì œ ì—ì–´íŒŸ ì™„ì „ì²´ëŠ” ë‹¹ì‹ ì˜ ê²ƒ!</h2>
                    <div class="swipe-card">
                        <div class="swipe-title">ì•„ì´í° ë°€ì–´ì„œ ì „í™”ë°›ê¸°ì²˜ëŸ¼</div>
                        <div class="swipe-track" id="swipeTrack">
                            <div class="swipe-text">ì—ì–´íŒŸ ìˆ˜ë ¹</div>
                            <div class="swipe-handle" id="swipeHandle">â†’</div>
                        </div>
                    </div>
                </div>
                <div id="finalLose" style="display: none;">
                    <h2>íŒ¨ë°°</h2>
                    <p class="final-copy">
                        <span class="line">ë•ë¶„ì— ìƒëŒ€ë°©ì´ ì™„ì „í•œ ì—ì–´íŒŸì„ ì¦ê¸¸ ìˆ˜ ìˆì–´ìš”<span class="emoji">ğŸ§</span></span>
                        <span class="line">ì•„, ì¢‹ì€ ìŠ¹ë¶€ì˜€ë‹¤<span class="emoji">ğŸ˜‡</span></span>
                        <span class="line">ğŸ˜‰ ë˜ ë‹¤ë¥¸ í–‰ìš´ì´ ì˜¬ê±°ì˜ˆìš” <span class="emoji">ğŸ€</span></span>
                    </p>
                    <a href="index.html" class="btn-main">ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</a>
                </div>
            </div>
        </div>
    </div>

    <div id="waitingPopup" class="waiting-popup hidden" role="dialog" aria-modal="true" aria-label="ëŒ€ê¸° íŒì—…">
        <div class="waiting-card">
            <div class="waiting-title">ìƒëŒ€ì˜ íŒ¨ë¥¼ ê¸°ë‹¤ë¦¬ê³  ìˆìŠµë‹ˆë‹¤</div>
            <p class="waiting-sub">ìƒëŒ€ëŠ” ìº¡ìŠì„ ì—´ê¸° ì „ì— ìì‹ ì˜ íŒ¨ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.</p>
            <div class="waiting-timer"><span id="waitingTimer">7</span>ì´ˆ</div>
        </div>
    </div>

    <div id="countdownOverlay" class="countdown-overlay hidden" aria-hidden="true">
        <div class="count-num" id="countdownNum">7</div>
    </div>

    <script>
        // Supabase ì„¤ì •
        const SUPABASE_URL = 'https://crptwupxsctalwlltruh.supabase.co';
        const SUPABASE_ANON_KEY = 'sb_publishable_T8l7VJH5FmJqrYwohTzzGw_k8gep3T0';

        const CHOICES = ['ê°€ìœ„', 'ë°”ìœ„', 'ë³´'];
        const CHOICE_EMOJI = { 'ê°€ìœ„': 'âœŒï¸', 'ë°”ìœ„': 'âœŠ', 'ë³´': 'ğŸ–ï¸', 'timeout': 'â³' };

        function encodeChoice(choice, ts) {
            const t = typeof ts === 'number' ? ts : Date.now();
            return String(choice) + '@' + String(t);
        }
        function decodeChoice(value) {
            if (!value) return { choice: null, ts: null, raw: null };
            const raw = String(value);
            const parts = raw.split('@');
            const choice = parts[0] || null;
            const ts = parts.length > 1 ? Number(parts[1]) : null;
            return { choice: choice, ts: Number.isFinite(ts) ? ts : null, raw: raw };
        }

        function getMyKey() {
            // íƒ­(ì„¸ì…˜)ë³„ë¡œ ê³ ìœ  í‚¤ë¥¼ ì‚¬ìš©í•´ ë™ì¼ ë¸Œë¼ìš°ì € ë‹¤ì¤‘ íƒ­ ì¶©ëŒ ë°©ì§€
            let k = sessionStorage.getItem('kong_key_session');
            if (!k) {
                k = 'k_' + Math.random().toString(36).slice(2) + '_' + Date.now();
                sessionStorage.setItem('kong_key_session', k);
            }
            return k;
        }

        function computeResult(my, opp) {
            const m = decodeChoice(my).choice || my;
            const o = decodeChoice(opp).choice || opp;
            if (m === o) return 'draw';
            if (m === 'timeout' && o === 'timeout') return 'draw';
            if (m === 'timeout') return 'lose';
            if (o === 'timeout') return 'win';
            if ((m === 'ê°€ìœ„' && o === 'ë³´') || (m === 'ë°”ìœ„' && o === 'ê°€ìœ„') || (m === 'ë³´' && o === 'ë°”ìœ„')) return 'win';
            return 'lose';
        }

        let realtimeRoomId = null;
        let realtimeUnsub = [];
        let realtimePollTimer = null;
        let realtimeHeartbeatTimer = null;
        let realtimeRenderRetryTimer = null;
        let foundToastShown = false;

        async function leaveRealtime() {
            console.log('ë§¤ì¹­ ì¢…ë£Œ ë° ì •ë¦¬ ì‹œì‘...');
            
            // íƒ€ì´ë¨¸ ì •ë¦¬
            if (realtimePollTimer) clearInterval(realtimePollTimer);
            realtimePollTimer = null;
            if (realtimeHeartbeatTimer) clearInterval(realtimeHeartbeatTimer);
            realtimeHeartbeatTimer = null;
            if (realtimeRenderRetryTimer) clearInterval(realtimeRenderRetryTimer);
            realtimeRenderRetryTimer = null;
            
            // ì±„ë„ êµ¬ë… í•´ì œ
            realtimeUnsub.forEach(ch => { 
                try { 
                    ch.unsubscribe(); 
                    console.log('ì±„ë„ êµ¬ë… í•´ì œ ì™„ë£Œ');
                } catch(e) {
                    console.error('ì±„ë„ êµ¬ë… í•´ì œ ì˜¤ë¥˜:', e);
                } 
            });
            realtimeUnsub.length = 0;
            
            // ë§¤ì¹­ íì—ì„œ ì œê±° + ë‚´ ì§„í–‰ ì¤‘ ë°© ì •ë¦¬
            if (SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL !== 'YOUR_SUPABASE_URL') {
                try {
                    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                    const myKey = getMyKey();

                    // ë‚´ê°€ ì†í•œ ì§„í–‰ ì¤‘ ë°©ì€ ì¢…ë£Œ ì²˜ë¦¬ (ë‹¤ìŒ ë§¤ì¹­ ë°©í•´ ë°©ì§€)
                    try {
                        await supabase
                            .from('rooms')
                            .update({
                                status: 'done',
                                p1_choice: null,
                                p2_choice: null
                            })
                            .or(`player1_key.eq.${myKey},player2_key.eq.${myKey}`)
                            .eq('status', 'playing');
                        console.log('ì§„í–‰ ì¤‘ ë°© ì¢…ë£Œ ì²˜ë¦¬ ì™„ë£Œ');
                    } catch (roomCleanupError) {
                        console.error('ì§„í–‰ ì¤‘ ë°© ì •ë¦¬ ì˜¤ë¥˜:', roomCleanupError);
                    }

                    const { data: q } = await supabase.from('matchmaking').select('player1_key, player2_key').eq('id', 1).single();
                    if (q && (q.player1_key === myKey || q.player2_key === myKey)) {
                        const updates = {};
                        if (q.player1_key === myKey) updates.player1_key = null;
                        if (q.player2_key === myKey) updates.player2_key = null;
                        updates.updated_at = new Date().toISOString();
                        await supabase.from('matchmaking').update(updates).eq('id', 1);
                        console.log('ë§¤ì¹­ íì—ì„œ ì œê±° ì™„ë£Œ');
                    }
                } catch (error) {
                    console.error('ë§¤ì¹­ í ì •ë¦¬ ì˜¤ë¥˜:', error);
                }
            }
            
            // ìƒíƒœ ì´ˆê¸°í™”
            realtimeRoomId = null;
            document.getElementById('realtimeStatus').textContent = 'ìƒëŒ€ë¥¼ ì°¾ëŠ” ì¤‘...';
            document.getElementById('realtimeStatus').classList.remove('found');
            document.getElementById('rtChoices').style.display = 'none';
            document.getElementById('realtimeFinal').style.display = 'none';
            document.getElementById('rtResultMsg').textContent = '';
            document.getElementById('rtMyScore').textContent = '0';
            document.getElementById('rtOppScore').textContent = '0';
            // ìº¡ìŠ/ì¹´ìš´íŠ¸ë‹¤ìš´ UI ì •ë¦¬
            const waitingPopup = document.getElementById('waitingPopup');
            if (waitingPopup) waitingPopup.classList.add('hidden');
            const countdownOverlay = document.getElementById('countdownOverlay');
            if (countdownOverlay) countdownOverlay.classList.add('hidden');
            const roundEl = document.getElementById('rtRoundInfo');
            if (roundEl) roundEl.textContent = '';
            foundToastShown = false;
            
            console.log('ë§¤ì¹­ ì¢…ë£Œ ë° ì •ë¦¬ ì™„ë£Œ');
        }

        async function startRealtime() {
            if (!SUPABASE_URL || !SUPABASE_ANON_KEY || SUPABASE_URL === 'YOUR_SUPABASE_URL') {
                document.getElementById('realtimeStatus').textContent = 'âš ï¸ Supabase URL/í‚¤ë¥¼ ì„¤ì •í•´ ì£¼ì„¸ìš”. (destiny.html ìƒë‹¨)';
                document.getElementById('realtimeStatus').style.color = '#f87171';
                console.error('Supabase ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤. destiny.html ìƒë‹¨ì˜ SUPABASE_URLê³¼ SUPABASE_ANON_KEYë¥¼ ì„¤ì •í•˜ì„¸ìš”.');
                return;
            }
            
            console.log('ì‹¤ì‹œê°„ ë§¤ì¹­ ì‹œì‘...');
            document.getElementById('realtimeStatus').textContent = 'ìƒëŒ€ë¥¼ ì°¾ëŠ” ì¤‘...';
            document.getElementById('realtimeStatus').style.color = '';
            
            // ê¸°ì¡´ ì—°ê²° ì •ë¦¬
            await leaveRealtime();
            
            // ì ì‹œ ëŒ€ê¸° (ì •ë¦¬ ì‹œê°„ í™•ë³´)
            await new Promise(resolve => setTimeout(resolve, 300));
            
            const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            const myKey = getMyKey();
            console.log('ë‚´ í‚¤:', myKey);
            console.log('ë‚´ í‚¤:', myKey);

            let { data: queue } = await supabase.from('matchmaking').select('*').eq('id', 1).single();
            
            // ê¸°ì¡´ ì™„ë£Œëœ ë§¤ì¹­ ì •ë¦¬ (ì˜¤ë˜ëœ ë§¤ì¹­ë„ ì •ë¦¬)
            if (queue) {
                const queueAge = queue.updated_at ? (Date.now() - new Date(queue.updated_at).getTime()) : Infinity;
                // 30ì´ˆ ì´ìƒ ëœ ë§¤ì¹­ì€ ìë™ ì •ë¦¬
                if ((queue.player1_key && queue.player2_key) || queueAge > 30000) {
                    console.log('ê¸°ì¡´ ì™„ë£Œëœ/ì˜¤ë˜ëœ ë§¤ì¹­ ì •ë¦¬ ì¤‘...', { queueAge });
                    await supabase.from('matchmaking').update({ player1_key: null, player2_key: null, updated_at: new Date().toISOString() }).eq('id', 1);
                    queue = { ...queue, player1_key: null, player2_key: null };
                }
            }
            
            // ëŒ€ê¸°ì—´ì— ì¶”ê°€ (ë ˆì´ìŠ¤ ë°©ì§€ìš© ì¡°ê±´ë¶€ ì—…ë°ì´íŠ¸)
            async function claimQueueSlot() {
                for (let i = 0; i < 8; i++) {
                    const { data: q } = await supabase.from('matchmaking').select('*').eq('id', 1).single();
                    if (!q) return null;

                    const queueAge = q.updated_at ? (Date.now() - new Date(q.updated_at).getTime()) : Infinity;
                    if (queueAge > 20000 && (q.player1_key || q.player2_key)) {
                        console.warn('âš ï¸ ì˜¤ë˜ëœ ëŒ€ê¸°ì—´ ê°ì§€, ì´ˆê¸°í™”', { queueAge });
                        await supabase.from('matchmaking').update({ player1_key: null, player2_key: null, updated_at: new Date().toISOString() }).eq('id', 1);
                        await new Promise(resolve => setTimeout(resolve, 200));
                        continue;
                    }

                    if (q.player1_key === myKey || q.player2_key === myKey) {
                        return q.player1_key === myKey ? 'player1' : 'player2';
                    }

                    const now = new Date().toISOString();

                    if (!q.player1_key) {
                        const { data: updated } = await supabase
                            .from('matchmaking')
                            .update({ player1_key: myKey, updated_at: now })
                            .eq('id', 1)
                            .is('player1_key', null)
                            .select('*')
                            .maybeSingle();
                        if (updated && updated.player1_key === myKey) return 'player1';
                    } else if (!q.player2_key && q.player1_key !== myKey) {
                        const { data: updated } = await supabase
                            .from('matchmaking')
                            .update({ player2_key: myKey, updated_at: now })
                            .eq('id', 1)
                            .is('player2_key', null)
                            .neq('player1_key', myKey)
                            .select('*')
                            .maybeSingle();
                        if (updated && updated.player2_key === myKey) return 'player2';
                    } else {
                        return 'full';
                    }

                    await new Promise(resolve => setTimeout(resolve, 250));
                }
                return null;
            }

            function startQueueHeartbeat(role) {
                if (realtimeHeartbeatTimer) clearInterval(realtimeHeartbeatTimer);
                realtimeHeartbeatTimer = setInterval(async () => {
                    try {
                        const { data: q } = await supabase.from('matchmaking').select('player1_key, player2_key').eq('id', 1).single();
                        if (!q) return;
                        const stillMine = (role === 'player1' && q.player1_key === myKey) || (role === 'player2' && q.player2_key === myKey);
                        if (!stillMine) {
                            clearInterval(realtimeHeartbeatTimer);
                            realtimeHeartbeatTimer = null;
                            return;
                        }
                        await supabase.from('matchmaking').update({ updated_at: new Date().toISOString() }).eq('id', 1);
                    } catch (e) {
                        console.error('ëŒ€ê¸°ì—´ í•˜íŠ¸ë¹„íŠ¸ ì˜¤ë¥˜:', e);
                    }
                }, 5000);
            }

            const role = await claimQueueSlot();
            if (role === 'player1') {
                console.log('Player1ë¡œ ëŒ€ê¸°ì—´ì— ì¶”ê°€ ì™„ë£Œ');
                document.getElementById('realtimeStatus').textContent = 'ìƒëŒ€ë¥¼ ì°¾ëŠ” ì¤‘... (Player1)';
                startQueueHeartbeat('player1');
            } else if (role === 'player2') {
                console.log('Player2ë¡œ ëŒ€ê¸°ì—´ì— ì¶”ê°€ ì™„ë£Œ');
                document.getElementById('realtimeStatus').textContent = 'ìƒëŒ€ë¥¼ ì°¾ëŠ” ì¤‘... (Player2)';
                startQueueHeartbeat('player2');
            } else if (role === 'full') {
                document.getElementById('realtimeStatus').textContent = 'ëŒ€ê¸°ì—´ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.';
                console.warn('ëŒ€ê¸°ì—´ì´ ê°€ë“ ì°¸');
                return;
            } else {
                document.getElementById('realtimeStatus').textContent = 'ëŒ€ê¸°ì—´ ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.';
                console.warn('ëŒ€ê¸°ì—´ ë“±ë¡ ì‹¤íŒ¨');
                return;
            }

            const chQueue = supabase.channel('queue').on('postgres_changes', { event: '*', schema: 'public', table: 'matchmaking', filter: 'id=eq.1' }, async (payload) => {
                const r = payload.new;
                console.log('ë§¤ì¹­ í ë³€ê²½ ê°ì§€:', r);
                if (!r || !r.player1_key || !r.player2_key) return;
                const p1 = r.player1_key;
                const p2 = r.player2_key;
                if (p1 === p2) {
                    console.warn('âš ï¸ ë™ì¼ í‚¤ë¡œ ë§¤ì¹­ë¨, í ì´ˆê¸°í™”');
                    await supabase.from('matchmaking').update({ player1_key: null, player2_key: null, updated_at: new Date().toISOString() }).eq('id', 1);
                    return;
                }
                if (p1 !== myKey && p2 !== myKey) {
                    console.log('ë‹¤ë¥¸ í”Œë ˆì´ì–´ë“¤ì˜ ë§¤ì¹­ì…ë‹ˆë‹¤.');
                    return;
                }
                if (p1 === myKey) {
                    console.log('Player1ë¡œ ë§¤ì¹­ë¨! ë°© ìƒì„± ì¤‘...');
                    const { data: room } = await supabase.from('rooms').insert({ player1_key: p1, player2_key: p2, round: 1, status: 'playing', p1_choice: null, p2_choice: null, p1_score: 0, p2_score: 0 }).select('id').single();
                    if (room) {
                        console.log('ë°© ìƒì„± ì™„ë£Œ:', room.id);
                        await supabase.from('matchmaking').update({ player1_key: null, player2_key: null }).eq('id', 1);
                        enterRoom(supabase, room.id, myKey, p1, p2);
                    }
                }
            });
            chQueue.subscribe();
            realtimeUnsub.push(chQueue);

            const chRooms = supabase.channel('my_rooms').on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'rooms' }, async (payload) => {
                const r = payload.new;
                console.log('ğŸ”” ìƒˆ ë°© ìƒì„± ê°ì§€ (chRooms):', r);
                console.log('ğŸ” ì…ì¥ ì¡°ê±´ í™•ì¸:', {
                    hasRoom: !!r,
                    hasP1: !!r?.player1_key,
                    hasP2: !!r?.player2_key,
                    isMyRoom: r && (r.player1_key === myKey || r.player2_key === myKey),
                    alreadyInRoom: !!realtimeRoomId,
                    myKey: myKey
                });
                
                // ë‘ ëª…ì´ ëª¨ë‘ ìˆì–´ì•¼ë§Œ ì…ì¥
                if (r && r.player1_key && r.player2_key && (r.player1_key === myKey || r.player2_key === myKey) && !realtimeRoomId) {
                    const isPlayer2 = r.player2_key === myKey;
                    console.log(`âœ… ${isPlayer2 ? 'Player2' : 'Player1'}ë¡œ ë°© ì…ì¥ ì‹œì‘...`, {
                        Player1: r.player1_key,
                        Player2: r.player2_key,
                        ë‚´í‚¤: myKey,
                        ë°©ID: r.id
                    });
                    
                    // player2ê°€ ë§¤ì¹­ë  ë•Œ ì²˜ë¦¬
                    realtimeUnsub.forEach(ch => { try { ch.unsubscribe(); } catch(e) {} });
                    realtimeUnsub.length = 0;
                    
                    // enterRoom í˜¸ì¶œ ì „ì— ìƒíƒœ í™•ì¸
                    console.log('ğŸšª enterRoom í˜¸ì¶œ ì „ ìƒíƒœ:', {
                        realtimeRoomId,
                        roomId: r.id
                    });
                    
                    await enterRoom(supabase, r.id, myKey, r.player1_key, r.player2_key);
                    
                    console.log('âœ… enterRoom í˜¸ì¶œ ì™„ë£Œ');
                } else {
                    console.log('â¸ï¸ ë°© ì…ì¥ ì¡°ê±´ ë¶ˆë§Œì¡±:', {
                        hasRoom: !!r,
                        hasP1: !!r?.player1_key,
                        hasP2: !!r?.player2_key,
                        isMyRoom: r && (r.player1_key === myKey || r.player2_key === myKey),
                        alreadyInRoom: !!realtimeRoomId
                    });
                }
            });
            chRooms.subscribe();
            realtimeUnsub.push(chRooms);

            async function tryMatch() {
                if (realtimeRoomId) return;

                // ë§¤ì¹­ í í™•ì¸
                const { data: q } = await supabase.from('matchmaking').select('*').eq('id', 1).single();
                const p1 = q && q.player1_key, p2 = q && q.player2_key;
                const queueAge = q && q.updated_at ? (Date.now() - new Date(q.updated_at).getTime()) : Infinity;
                if (queueAge > 20000 && (p1 || p2)) {
                    console.warn('âš ï¸ ì˜¤ë˜ëœ ëŒ€ê¸°ì—´ ê°ì§€, ì´ˆê¸°í™”', { queueAge });
                    await supabase.from('matchmaking').update({ player1_key: null, player2_key: null, updated_at: new Date().toISOString() }).eq('id', 1);
                    return;
                }
                if (p1 && p2 && p1 === p2) {
                    console.warn('âš ï¸ ë™ì¼ í‚¤ë¡œ ë§¤ì¹­ë¨, í ì´ˆê¸°í™”');
                    await supabase.from('matchmaking').update({ player1_key: null, player2_key: null, updated_at: new Date().toISOString() }).eq('id', 1);
                    return;
                }

                // ë‘ ëª…ì´ ëª¨ë‘ ë§¤ì¹­ íì— ìˆì„ ë•Œë§Œ ì²˜ë¦¬
                if (p1 && p2 && (p1 === myKey || p2 === myKey)) {
                    // player1ì¸ ê²½ìš°ì—ë§Œ ë°© ìƒì„± (ì¤‘ë³µ ë°©ì§€)
                    if (p1 === myKey) {
                        // ì´ë¯¸ ìƒì„±ëœ ë°©ì´ ìˆëŠ”ì§€ í™•ì¸
                        let { data: room } = await supabase
                            .from('rooms')
                            .select('id, player1_key, player2_key')
                            .eq('player1_key', p1)
                            .eq('player2_key', p2)
                            .eq('status', 'playing')
                            .order('created_at', { ascending: false })
                            .limit(1)
                            .maybeSingle();
                        
                        if (!room) {
                            // ìƒˆ ë°© ìƒì„±
                            console.log('ìƒˆ ë°© ìƒì„± ì¤‘...');
                            const res = await supabase.from('rooms').insert({ 
                                player1_key: p1, 
                                player2_key: p2, 
                                round: 1, 
                                status: 'playing', 
                                p1_choice: null, 
                                p2_choice: null, 
                                p1_score: 0, 
                                p2_score: 0 
                            }).select('id').single();
                            room = res.data;
                            
                            if (room) {
                                // ë§¤ì¹­ í ë¹„ìš°ê¸°
                                await supabase.from('matchmaking').update({ player1_key: null, player2_key: null }).eq('id', 1);
                                console.log('ë°© ìƒì„± ì™„ë£Œ, ë§¤ì¹­ í ë¹„ì›€');
                            }
                        }
                        
                        // ë°©ì´ ìˆê³  ì•„ì§ ì…ì¥í•˜ì§€ ì•Šì•˜ìœ¼ë©´ ì…ì¥
                        if (room && !realtimeRoomId && room.player1_key && room.player2_key) {
                            if (realtimePollTimer) clearInterval(realtimePollTimer);
                            realtimePollTimer = null;
                            enterRoom(supabase, room.id, myKey, room.player1_key, room.player2_key);
                            return;
                        }
                    } else if (p2 === myKey) {
                        // player2ëŠ” INSERT ì´ë²¤íŠ¸ë¥¼ ë†“ì¹  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë°©ì„ ì§ì ‘ ì°¾ëŠ”ë‹¤
                        const { data: existingRoom } = await supabase
                            .from('rooms')
                            .select('id, player1_key, player2_key')
                            .eq('player1_key', p1)
                            .eq('player2_key', p2)
                            .eq('status', 'playing')
                            .order('created_at', { ascending: false })
                            .limit(1)
                            .maybeSingle();

                        if (existingRoom && !realtimeRoomId && existingRoom.player1_key && existingRoom.player2_key) {
                            if (realtimePollTimer) clearInterval(realtimePollTimer);
                            realtimePollTimer = null;
                            enterRoom(supabase, existingRoom.id, myKey, existingRoom.player1_key, existingRoom.player2_key);
                            return;
                        }
                    }
                    // player2ëŠ” chRooms ì±„ë„ì„ í†µí•´ ìë™ìœ¼ë¡œ ì…ì¥ë¨
                }

                // íê°€ ë¹„ì›Œì¡Œê±°ë‚˜ ì´ë²¤íŠ¸ë¥¼ ë†“ì¹œ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ë‚´ ë°©ì„ ì§ì ‘ ì°¾ê¸°
                if (!realtimeRoomId) {
                    const { data: myRoom } = await supabase
                        .from('rooms')
                        .select('id, player1_key, player2_key, status')
                        .or(`player1_key.eq.${myKey},player2_key.eq.${myKey}`)
                        .eq('status', 'playing')
                        .order('created_at', { ascending: false })
                        .limit(1)
                        .maybeSingle();

                    if (myRoom && myRoom.player1_key && myRoom.player2_key) {
                        if (realtimePollTimer) clearInterval(realtimePollTimer);
                        realtimePollTimer = null;
                        enterRoom(supabase, myRoom.id, myKey, myRoom.player1_key, myRoom.player2_key);
                        return;
                    }
                }
            }

            setTimeout(tryMatch, 400);
            realtimePollTimer = setInterval(tryMatch, 1200);
        }

        async function enterRoom(supabase, roomId, myKey, p1Key, p2Key) {
            console.log('ğŸšª enterRoom í•¨ìˆ˜ ì‹œì‘:', { roomId, myKey, p1Key, p2Key });
            foundToastShown = false;
            
            // ì´ë¯¸ ê°™ì€ ë°©ì— ìˆìœ¼ë©´ ì¤‘ë³µ ì§„ì… ë°©ì§€
            if (realtimeRoomId === roomId) {
                console.log('â¸ï¸ ì´ë¯¸ ê°™ì€ ë°©ì— ìˆìŠµë‹ˆë‹¤.');
                return;
            }
            
            // ìƒëŒ€ë°©ì´ ì‹¤ì œë¡œ ìˆëŠ”ì§€ í™•ì¸
            if (!p1Key || !p2Key) {
                console.error('âŒ ìƒëŒ€ë°©ì´ ì—†ìŠµë‹ˆë‹¤. Player1:', p1Key, 'Player2:', p2Key);
                document.getElementById('realtimeStatus').textContent = 'ìƒëŒ€ë°©ì„ ì°¾ëŠ” ì¤‘...';
                document.getElementById('rtChoices').style.display = 'none';
                return;
            }
            
            // ì‹¤ì œ ë°© ë°ì´í„°ë¥¼ ë‹¤ì‹œ í™•ì¸í•˜ì—¬ ìƒëŒ€ë°©ì´ í™•ì‹¤íˆ ìˆëŠ”ì§€ ê²€ì¦
            const { data: roomData, error: roomDataError } = await supabase.from('rooms').select('player1_key, player2_key, status').eq('id', roomId).single();
            if (roomDataError) {
                console.error('âŒ ë°© ë°ì´í„° ì¡°íšŒ ì˜¤ë¥˜:', roomDataError);
            }
            if (!roomData || !roomData.player1_key || !roomData.player2_key) {
                console.error('âŒ ë°© ë°ì´í„°ì— ìƒëŒ€ë°©ì´ ì—†ìŠµë‹ˆë‹¤:', roomData);
                document.getElementById('realtimeStatus').textContent = 'ìƒëŒ€ë°©ì„ ì°¾ëŠ” ì¤‘...';
                document.getElementById('rtChoices').style.display = 'none';
                return;
            }
            
            console.log('âœ… ë°© ì…ì¥:', { roomId, Player1: p1Key, Player2: p2Key, ë‚´í‚¤: myKey });
            
            // ê¸°ì¡´ ì—°ê²° ì •ë¦¬
            if (realtimePollTimer) clearInterval(realtimePollTimer);
            realtimePollTimer = null;
            if (realtimeHeartbeatTimer) clearInterval(realtimeHeartbeatTimer);
            realtimeHeartbeatTimer = null;
            if (realtimeRenderRetryTimer) clearInterval(realtimeRenderRetryTimer);
            realtimeRenderRetryTimer = null;
            realtimeUnsub.forEach(ch => { try { ch.unsubscribe(); } catch(e) {} });
            realtimeUnsub.length = 0;
            realtimeRoomId = roomId;
            const amPlayer1 = p1Key === myKey;
            console.log(`ğŸ‘¤ ë‚˜ëŠ” Player ${amPlayer1 ? '1' : '2'}`);
            
            // DOM ìš”ì†Œ ë¨¼ì € ê°€ì ¸ì˜¤ê¸°
            const rtMyScoreEl = document.getElementById('rtMyScore');
            const rtOppScoreEl = document.getElementById('rtOppScore');
            const rtRoundInfo = document.getElementById('rtRoundInfo');
            const rtResultMsg = document.getElementById('rtResultMsg');
            const rtChoices = document.getElementById('rtChoices');
            const rtWaiting = document.getElementById('rtWaiting');
            const rtFinal = document.getElementById('realtimeFinal');
            const capsuleArea = document.getElementById('capsuleArea');
            const myCapsule = document.getElementById('myCapsule');
            const oppCapsule = document.getElementById('oppCapsule');
            const myCapsuleContent = document.getElementById('myCapsuleContent');
            const oppCapsuleContent = document.getElementById('oppCapsuleContent');
            const waitingPopup = document.getElementById('waitingPopup');
            const waitingTimer = document.getElementById('waitingTimer');
            const countdownOverlay = document.getElementById('countdownOverlay');
            const countdownNum = document.getElementById('countdownNum');

            const COUNTDOWN_MS = 7000;
            let countdownInterval = null;
            let countdownStartTs = null;
            let countdownDeadlineTs = null;
            let countdownMissingField = null; // 'p1_choice' | 'p2_choice'
            let timeoutSent = false;
            let prevBothChose = false;
            let statusToast = document.getElementById('statusToast');
            if (!statusToast) {
                statusToast = document.createElement('div');
                statusToast.id = 'statusToast';
                statusToast.className = 'status-toast';
                statusToast.textContent = 'ìƒëŒ€ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤!';
                document.body.appendChild(statusToast);
            }
            const finalWin = document.getElementById('finalWin');
            const finalLose = document.getElementById('finalLose');
            const confettiLayer = document.getElementById('confettiLayer');
            const swipeTrack = document.getElementById('swipeTrack');
            const swipeHandle = document.getElementById('swipeHandle');

            function buildConfetti() {
                if (!confettiLayer || confettiLayer.children.length) return;
                const colors = ['#f87171', '#fbbf24', '#34d399', '#60a5fa', '#a78bfa', '#f472b6'];
                for (let i = 0; i < 18; i++) {
                    const piece = document.createElement('span');
                    piece.style.left = Math.random() * 100 + '%';
                    piece.style.animationDelay = (Math.random() * 2) + 's';
                    piece.style.background = colors[i % colors.length];
                    confettiLayer.appendChild(piece);
                }
            }

            function setupSwipe() {
                if (!swipeTrack || !swipeHandle || swipeHandle.dataset.bound === 'true') return;
                swipeHandle.dataset.bound = 'true';
                let dragging = false;
                let startX = 0;
                let startLeft = 0;
                const maxLeft = () => swipeTrack.clientWidth - swipeHandle.clientWidth - 8;

                const onDown = (e) => {
                    dragging = true;
                    startX = e.clientX;
                    startLeft = parseFloat(getComputedStyle(swipeHandle).left) || 4;
                    swipeHandle.setPointerCapture(e.pointerId);
                };

                const onMove = (e) => {
                    if (!dragging) return;
                    const dx = e.clientX - startX;
                    let next = Math.min(Math.max(startLeft + dx, 4), maxLeft());
                    swipeHandle.style.left = next + 'px';
                };

                const onUp = () => {
                    if (!dragging) return;
                    dragging = false;
                    const progress = (parseFloat(getComputedStyle(swipeHandle).left) - 4) / maxLeft();
                    if (progress > 0.6) {
                        location.href = 'receipt.html';
                        return;
                    }
                    swipeHandle.style.left = '4px';
                };

                swipeHandle.addEventListener('pointerdown', onDown);
                swipeHandle.addEventListener('pointermove', onMove);
                swipeHandle.addEventListener('pointerup', onUp);
                swipeHandle.addEventListener('pointercancel', onUp);
            }

            function resetChoicesUI() {
                rtChoices.innerHTML = `
                    <button class="choice-btn rt-choice" data-choice="ê°€ìœ„">
                        <span class="choice-emoji">âœŒï¸</span>
                    </button>
                    <button class="choice-btn rt-choice" data-choice="ë°”ìœ„">
                        <span class="choice-emoji">âœŠ</span>
                    </button>
                    <button class="choice-btn rt-choice" data-choice="ë³´">
                        <span class="choice-emoji">ğŸ–ï¸</span>
                    </button>
                `;
                rtChoices.removeAttribute('hidden');
                rtChoices.classList.remove('hidden');
                rtChoices.classList.add('choices');
                if (!amPlayer1) {
                    rtChoices.classList.add('player2-active');
                }
                rtChoices.style.display = 'flex';
                rtChoices.style.visibility = 'visible';
                rtChoices.style.opacity = '1';
                rtChoices.style.height = 'auto';
                rtChoices.style.width = 'auto';
                rtChoices.style.position = 'relative';
            }

            function setCapsuleState(target, isOpen, emoji) {
                if (!target) return;
                target.classList.remove('open', 'sealed', 'reveal', 'pop');
                target.classList.add(isOpen ? 'open' : 'sealed');
                const c = target === myCapsule ? myCapsuleContent : oppCapsuleContent;
                if (c) c.textContent = emoji || 'â“';
            }

            function popCapsule(target) {
                if (!target) return;
                target.classList.remove('pop');
                void target.offsetWidth; // reflow
                target.classList.add('pop');
            }

            function hideWaitingPopup() {
                if (waitingPopup) waitingPopup.classList.add('hidden');
            }
            function showWaitingPopup(sec) {
                if (!waitingPopup || !waitingTimer) return;
                waitingTimer.textContent = String(sec);
                waitingPopup.classList.remove('hidden');
            }

            function hideCountdownOverlay() {
                if (countdownOverlay) countdownOverlay.classList.add('hidden');
            }
            function showCountdownOverlay(sec) {
                if (!countdownOverlay || !countdownNum) return;
                countdownNum.textContent = String(sec);
                countdownOverlay.classList.remove('hidden');

                // 4ì´ˆë¶€í„° ë°°ê²½ì„ ì ì  ë¹¨ê°›ê²Œ (ìœ„ê¸°ê°)
                if (sec <= 4) {
                    const alpha = ((4 - sec + 1) / 4) * 0.70; // sec=4 -> 0.175, sec=1 -> 0.70
                    countdownOverlay.style.background = `rgba(192, 57, 43, ${alpha})`;
                } else {
                    countdownOverlay.style.background = 'rgba(0,0,0,0.25)';
                }
            }

            function stopCountdownUI() {
                if (countdownInterval) clearInterval(countdownInterval);
                countdownInterval = null;
                countdownStartTs = null;
                countdownDeadlineTs = null;
                countdownMissingField = null;
                timeoutSent = false;
                hideWaitingPopup();
                hideCountdownOverlay();
            }

            async function tryForceTimeoutChoice(roomId) {
                if (timeoutSent || !countdownMissingField) return;
                timeoutSent = true;
                try {
                    const patch = {};
                    patch[countdownMissingField] = encodeChoice('timeout');
                    const { error } = await supabase
                        .from('rooms')
                        .update(patch)
                        .eq('id', roomId)
                        .is(countdownMissingField, null);
                    if (error) throw error;
                    console.log('â³ ì‹œê°„ ì´ˆê³¼ ì²˜ë¦¬ ì™„ë£Œ:', countdownMissingField);
                } catch (e) {
                    console.error('âŒ ì‹œê°„ ì´ˆê³¼ ì²˜ë¦¬ ì‹¤íŒ¨:', e);
                }
            }

            function ensureCountdownFrom(firstTs, missingField, iAmMissing, roomId) {
                const startTs = firstTs || Date.now();
                const deadlineTs = startTs + COUNTDOWN_MS;

                if (countdownStartTs === startTs && countdownMissingField === missingField) return;

                stopCountdownUI();
                countdownStartTs = startTs;
                countdownDeadlineTs = deadlineTs;
                countdownMissingField = missingField;
                timeoutSent = false;

                const tick = async () => {
                    const now = Date.now();
                    const remainMs = countdownDeadlineTs - now;
                    const sec = Math.max(0, Math.ceil(remainMs / 1000));

                    if (iAmMissing) showCountdownOverlay(sec);
                    else showWaitingPopup(sec);

                    if (remainMs <= 0) {
                        await tryForceTimeoutChoice(roomId);
                    }
                };

                tick();
                countdownInterval = setInterval(tick, 200);
            }
            
            // ì´ˆê¸° ìƒíƒœ ì„¤ì •
            console.log(`ë°© ì…ì¥ ì´ˆê¸°í™” - ${amPlayer1 ? 'Player1' : 'Player2'} ë²„íŠ¼ ìˆ¨ê¹€`);
            
            // Player2ì˜ ê²½ìš° player2-active í´ë˜ìŠ¤ ì¶”ê°€ (ì´ˆê¸°ë¶€í„°)
            if (!amPlayer1) {
                rtChoices.classList.add('player2-active');
                console.log('âœ… Player2 player2-active í´ë˜ìŠ¤ ì¶”ê°€');
            }
            
            rtChoices.style.display = 'none';
            rtChoices.style.visibility = 'hidden';
            rtWaiting.style.display = 'none';
            rtFinal.style.display = 'none';
            
            // Player2ë¥¼ ìœ„í•œ ì¦‰ì‹œ ë²„íŠ¼ í‘œì‹œ í•¨ìˆ˜ (renderRoom ì „ì— ì‹¤í–‰)
            function forceShowButtons() {
                console.log(`ğŸ”§ ${amPlayer1 ? 'Player1' : 'Player2'} ë²„íŠ¼ ê°•ì œ í‘œì‹œ í•¨ìˆ˜ ì‹¤í–‰`);
                const choicesEl = document.getElementById('rtChoices');
                if (choicesEl) {
                    // Player2 ì „ìš© í´ë˜ìŠ¤ ì¶”ê°€
                    if (!amPlayer1) {
                        choicesEl.classList.add('player2-active');
                    }
                    
                    choicesEl.style.display = 'flex';
                    choicesEl.style.visibility = 'visible';
                    choicesEl.style.opacity = '1';
                    choicesEl.style.height = 'auto';
                    choicesEl.style.width = 'auto';
                    choicesEl.removeAttribute('hidden');
                    choicesEl.classList.remove('hidden');
                    choicesEl.setAttribute('style', 'display: flex !important; visibility: visible !important; opacity: 1 !important; height: auto !important; width: auto !important; position: relative !important;');
                    
                    // ê° ë²„íŠ¼ë„ ê°•ì œ í‘œì‹œ
                    const buttons = choicesEl.querySelectorAll('.rt-choice');
                    buttons.forEach(btn => {
                        btn.style.display = 'inline-block';
                        btn.style.visibility = 'visible';
                        btn.style.opacity = '1';
                        btn.style.pointerEvents = 'auto';
                        btn.style.cursor = 'pointer';
                        btn.removeAttribute('hidden');
                    });
                    
                    console.log(`âœ… ${amPlayer1 ? 'Player1' : 'Player2'} ë²„íŠ¼ ê°•ì œ í‘œì‹œ ì™„ë£Œ`, {
                        í´ë˜ìŠ¤: choicesEl.className,
                        ë²„íŠ¼ê°œìˆ˜: buttons.length,
                        ë†’ì´: choicesEl.offsetHeight
                    });
                }
            }

            function renderRoom(room) {
                // ìƒëŒ€ë°©ì´ ì—†ìœ¼ë©´ ê²Œì„ UI ìˆ¨ê¹€
                if (!room || !room.player1_key || !room.player2_key) {
                    console.log('ìƒëŒ€ë°©ì´ ì—†ì–´ì„œ ê²Œì„ UI ìˆ¨ê¹€:', room);
                    rtChoices.style.display = 'none';
                    rtChoices.classList.remove('player2-active');
                    rtWaiting.style.display = 'none';
                    rtFinal.style.display = 'none';
                    document.getElementById('realtimeStatus').textContent = 'ìƒëŒ€ë°©ì„ ì°¾ëŠ” ì¤‘...';
                    document.getElementById('realtimeStatus').classList.remove('found');
                    return;
                }
                
                // ìƒëŒ€ë°©ì´ ìˆìœ¼ë©´ ë§¤ì¹­ ì™„ë£Œ ë©”ì‹œì§€ í‘œì‹œ
                document.getElementById('realtimeStatus').textContent = '';
                document.getElementById('realtimeStatus').classList.remove('found');
                if (!foundToastShown) {
                    foundToastShown = true;
                    statusToast.classList.add('show');
                    setTimeout(() => {
                        statusToast.classList.remove('show');
                    }, 1400);
                }
                
                // Player2ë¥¼ ìœ„í•´ ì¦‰ì‹œ ë²„íŠ¼ í‘œì‹œ (ê°€ì¥ ë¨¼ì € ì‹¤í–‰)
                if (!amPlayer1) {
                    console.log('ğŸš€ Player2 renderRoom ì‹œì‘ - ì¦‰ì‹œ ë²„íŠ¼ í‘œì‹œ');
                    forceShowButtons();
                }
                
                const myScore = amPlayer1 ? room.p1_score : room.p2_score;
                const oppScore = amPlayer1 ? room.p2_score : room.p1_score;
                rtMyScoreEl.textContent = myScore;
                rtOppScoreEl.textContent = oppScore;
                if (rtRoundInfo) rtRoundInfo.textContent = '';
                const myChoiceRaw = amPlayer1 ? room.p1_choice : room.p2_choice;
                const oppChoiceRaw = amPlayer1 ? room.p2_choice : room.p1_choice;
                const myDec = decodeChoice(myChoiceRaw);
                const oppDec = decodeChoice(oppChoiceRaw);
                const myChoice = myDec.choice;
                const oppChoice = oppDec.choice;
                
                if (room.status === 'done') {
                    rtChoices.style.display = 'none';
                    rtWaiting.style.display = 'none';
                    rtFinal.style.display = 'block';
                    stopCountdownUI();
                    if (myScore > oppScore) {
                        rtFinal.className = 'final-panel visible win';
                        finalWin.style.display = 'block';
                        finalLose.style.display = 'none';
                        buildConfetti();
                        setupSwipe();
                    } else if (myScore < oppScore) {
                        rtFinal.className = 'final-panel visible lose';
                        finalWin.style.display = 'none';
                        finalLose.style.display = 'block';
                    }
                    return;
                }
                
                if (capsuleArea) capsuleArea.style.display = 'flex';

                const bothChose = !!room.p1_choice && !!room.p2_choice;
                if (bothChose) {
                    stopCountdownUI();

                    const myEmoji = CHOICE_EMOJI[myChoice] || 'â“';
                    const oppEmoji = CHOICE_EMOJI[oppChoice] || 'â“';
                    setCapsuleState(myCapsule, true, myEmoji);
                    setCapsuleState(oppCapsule, true, oppEmoji);
                    if (!prevBothChose) {
                        myCapsule.classList.add('reveal');
                        oppCapsule.classList.add('reveal');
                        popCapsule(myCapsule);
                        popCapsule(oppCapsule);
                        setTimeout(() => {
                            myCapsule.classList.remove('reveal');
                            oppCapsule.classList.remove('reveal');
                        }, 650);
                    }
                    prevBothChose = true;

                    const res = computeResult(myChoiceRaw, oppChoiceRaw);
                    let resText = '';
                    if (res === 'win') resText = 'ìŠ¹ë¦¬!';
                    else if (res === 'lose') resText = 'íŒ¨ë°°';
                    else resText = 'ë¬´ìŠ¹ë¶€';
                    const myLabel = myChoice === 'timeout' ? 'ì‹œê°„ì´ˆê³¼' : (myChoice || 'â€”');
                    const oppLabel = oppChoice === 'timeout' ? 'ì‹œê°„ì´ˆê³¼' : (oppChoice || 'â€”');
                    rtResultMsg.textContent = 'ë‚˜: ' + myLabel + ' vs ìƒëŒ€: ' + oppLabel + ' â†’ ' + resText;

                    if (res === 'draw') {
                        rtWaiting.style.display = 'none';
                        resetChoicesUI();
                        rtChoices.style.display = 'flex';
                        rtChoices.querySelectorAll('.rt-choice').forEach(b => {
                            b.disabled = false;
                            b.removeAttribute('disabled');
                            b.style.opacity = '1';
                            b.style.cursor = 'pointer';
                            b.style.pointerEvents = 'auto';
                        });
                        rtResultMsg.textContent = 'ë¬´ìŠ¹ë¶€! ë‹¤ì‹œ ì„ íƒí•˜ì„¸ìš”.';
                    } else {
                        rtChoices.style.display = 'none';
                        rtWaiting.style.display = 'block';
                    }
                } else {
                    prevBothChose = false;

                    // ìº¡ìŠ: ë´‰ì¸ ìƒíƒœì—ì„œëŠ” íŒ¨ë¥¼ ê³µê°œí•˜ì§€ ì•ŠìŒ(ë‹´ê¹€ ì—¬ë¶€ë§Œ í‘œì‹œ)
                    setCapsuleState(myCapsule, false, myChoice ? 'ğŸ’Š' : 'â“');
                    setCapsuleState(oppCapsule, false, oppChoice ? 'ğŸ’Š' : 'â“');

                    const myChosen = !!myChoiceRaw;
                    const oppChosen = !!oppChoiceRaw;

                    // ëˆ„êµ°ê°€ ë¨¼ì € ì„ íƒí•˜ë©´ 7ì´ˆ ì•ˆì— ìƒëŒ€ë„ ì„ íƒí•´ì•¼ í•¨
                    if (myChosen !== oppChosen) {
                        const first = myChosen ? myDec : oppDec;
                        const firstTs = first && first.ts ? first.ts : Date.now();
                        const missingField = room.p1_choice ? 'p2_choice' : 'p1_choice';
                        ensureCountdownFrom(firstTs, missingField, !myChosen, roomId);
                    } else {
                        stopCountdownUI();
                    }

                    // ë‚´ê°€ ì´ë¯¸ ì„ íƒí–ˆê³  ìƒëŒ€ê°€ ì•„ì§ì´ë©´ ê¸´ë°• ëŒ€ê¸° UI
                    if (myChoice && !oppChoice) {
                        rtChoices.style.display = 'none';
                        rtWaiting.style.display = 'none'; // íŒì—…ìœ¼ë¡œ ëŒ€ê¸° í‘œì‹œ
                        rtResultMsg.textContent = '';
                        return;
                    }

                    // ìƒëŒ€ë°©ì´ ìˆì„ ë•Œë§Œ ì„ íƒ ë²„íŠ¼ í‘œì‹œ
                    console.log(`ğŸ® ${amPlayer1 ? 'Player1' : 'Player2'} ê²Œì„ ì§„í–‰ ì¤‘ - ë²„íŠ¼ í‘œì‹œ ì‹œì‘`, { 
                        myChoice, 
                        bothChose, 
                        status: room.status,
                        p1_choice: room.p1_choice,
                        p2_choice: room.p2_choice,
                        player1_key: room.player1_key,
                        player2_key: room.player2_key,
                        amPlayer1: amPlayer1,
                        ë‚´í‚¤: myKey
                    });
                    
                    // ë‹¤ë¥¸ UI ìš”ì†Œ ìˆ¨ê¸°ê¸°
                    rtWaiting.style.display = 'none';
                    rtFinal.style.display = 'none';
                    resetChoicesUI();
                    
                    // Player2ë¥¼ ìœ„í•´ ë¬´ì¡°ê±´ ë²„íŠ¼ í‘œì‹œ (ê°€ì¥ ë¨¼ì €)
                    if (!amPlayer1) {
                        console.log('ğŸš€ Player2 ë²„íŠ¼ ê°•ì œ í‘œì‹œ (ê²Œì„ ì§„í–‰ ì¤‘)');
                        rtChoices.classList.add('player2-active');
                        forceShowButtons();
                    }
                    
                    // 1. ê¸°ë³¸ ìŠ¤íƒ€ì¼ ì„¤ì •
                    rtChoices.style.display = 'flex';
                    rtChoices.style.visibility = 'visible';
                    rtChoices.style.opacity = '1';
                    rtChoices.style.height = 'auto';
                    rtChoices.style.width = 'auto';
                    rtChoices.style.position = 'relative';
                    
                    // 2. ì†ì„± ì œê±°
                    rtChoices.removeAttribute('hidden');
                    rtChoices.classList.remove('hidden');
                    
                    // 3. ì¸ë¼ì¸ ìŠ¤íƒ€ì¼ë¡œ ê°•ì œ ì„¤ì • (!important)
                    rtChoices.setAttribute('style', 'display: flex !important; visibility: visible !important; opacity: 1 !important; height: auto !important; width: auto !important; position: relative !important;');
                    
                    // 4. DOMì— ì§ì ‘ ì ‘ê·¼í•˜ì—¬ í™•ì¸
                    const rtChoicesElement = document.getElementById('rtChoices');
                    if (rtChoicesElement) {
                        rtChoicesElement.style.display = 'flex';
                        rtChoicesElement.style.visibility = 'visible';
                        rtChoicesElement.removeAttribute('hidden');
                        if (!amPlayer1) {
                            rtChoicesElement.classList.add('player2-active');
                        }
                    }
                    
                    // Player2ë¥¼ ìœ„í•´ ì—¬ëŸ¬ ë²ˆ ê°•ì œ í‘œì‹œ
                    if (!amPlayer1) {
                        setTimeout(() => {
                            console.log('ğŸš€ Player2 ë²„íŠ¼ ê°•ì œ í‘œì‹œ (50ms í›„)');
                            forceShowButtons();
                        }, 50);
                        setTimeout(() => {
                            console.log('ğŸš€ Player2 ë²„íŠ¼ ê°•ì œ í‘œì‹œ (150ms í›„)');
                            forceShowButtons();
                        }, 150);
                        setTimeout(() => {
                            console.log('ğŸš€ Player2 ë²„íŠ¼ ê°•ì œ í‘œì‹œ (300ms í›„)');
                            forceShowButtons();
                        }, 300);
                    }
                    
                    console.log(`âœ… ${amPlayer1 ? 'Player1' : 'Player2'} ë²„íŠ¼ ì»¨í…Œì´ë„ˆ í‘œì‹œ ì™„ë£Œ:`, {
                        display: rtChoices.style.display,
                        visibility: rtChoices.style.visibility,
                        computedDisplay: window.getComputedStyle(rtChoices).display,
                        computedVisibility: window.getComputedStyle(rtChoices).visibility,
                        offsetHeight: rtChoices.offsetHeight,
                        offsetWidth: rtChoices.offsetWidth,
                        clientHeight: rtChoices.clientHeight,
                        scrollHeight: rtChoices.scrollHeight
                    });
                    
                    // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸ ë° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ í™•ì¸
                    const buttons = rtChoices.querySelectorAll('.rt-choice');
                    console.log('ğŸ”˜ ì°¾ì€ ë²„íŠ¼ ê°œìˆ˜:', buttons.length);
                    
                    if (buttons.length === 0) {
                        console.error('âŒ ë²„íŠ¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
                    }
                    
                    buttons.forEach((btn, index) => {
                        const shouldDisable = !!myChoice;
                        btn.disabled = shouldDisable;
                        
                        // ì„ íƒí•˜ì§€ ì•Šì•˜ìœ¼ë©´ ë²„íŠ¼ ì™„ì „íˆ í™œì„±í™”
                        if (!myChoice) {
                            btn.style.opacity = '1';
                            btn.style.cursor = 'pointer';
                            btn.style.pointerEvents = 'auto';
                            btn.removeAttribute('disabled');
                            btn.classList.remove('disabled');
                            console.log(`âœ… ë²„íŠ¼ ${index + 1} í™œì„±í™”:`, btn.dataset.choice, {
                                disabled: btn.disabled,
                                opacity: btn.style.opacity,
                                display: window.getComputedStyle(btn).display
                            });
                        } else {
                            btn.style.opacity = '0.5';
                            btn.style.cursor = 'not-allowed';
                            btn.setAttribute('disabled', 'disabled');
                            console.log(`â¸ï¸ ë²„íŠ¼ ${index + 1} ë¹„í™œì„±í™” (ì´ë¯¸ ì„ íƒí•¨):`, btn.dataset.choice);
                        }
                    });
                    
                    if (!myChoice) {
                        rtResultMsg.textContent = '';
                        
                        // Player2ë¥¼ ìœ„í•´ ì¦‰ì‹œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì—°ê²°
                        console.log(`ğŸ”— ${amPlayer1 ? 'Player1' : 'Player2'} ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì—°ê²° ì‹œë„...`);
                        attachChoiceListeners();
                        
                        // Player2ë¥¼ ìœ„í•´ ì¶”ê°€ í™•ì¸ (ì—¬ëŸ¬ ë²ˆ)
                        setTimeout(() => {
                            const checkButtons = rtChoices.querySelectorAll('.rt-choice');
                            const computedStyle = window.getComputedStyle(rtChoices);
                            console.log(`ğŸ” ${amPlayer1 ? 'Player1' : 'Player2'} ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ í™•ì¸ (1ì°¨):`, {
                                ë²„íŠ¼ê°œìˆ˜: checkButtons.length,
                                í‘œì‹œìƒíƒœ: rtChoices.style.display,
                                ê³„ì‚°ëœí‘œì‹œ: computedStyle.display,
                                ê³„ì‚°ëœê°€ì‹œì„±: computedStyle.visibility,
                                ë†’ì´: rtChoices.offsetHeight
                            });
                            
                            // Player2ì˜ ê²½ìš° ë” ì ê·¹ì ìœ¼ë¡œ ì²˜ë¦¬
                            if (!amPlayer1 && (rtChoices.style.display !== 'flex' || computedStyle.display !== 'flex' || rtChoices.offsetHeight === 0)) {
                                console.warn(`âš ï¸ Player2 ë²„íŠ¼ì´ ì—¬ì „íˆ ìˆ¨ê²¨ì ¸ ìˆìŒ, ê°•ì œ í‘œì‹œ ì‹œë„`);
                                forceShowButtons();
                                attachChoiceListeners();
                            }
                        }, 300);
                        
                        // Player2ë¥¼ ìœ„í•´ 2ì°¨ í™•ì¸
                        setTimeout(() => {
                            if (!amPlayer1) {
                                const checkButtons2 = rtChoices.querySelectorAll('.rt-choice');
                                const computedStyle2 = window.getComputedStyle(rtChoices);
                                console.log(`ğŸ” Player2 ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ í™•ì¸ (2ì°¨):`, {
                                    ë²„íŠ¼ê°œìˆ˜: checkButtons2.length,
                                    í‘œì‹œìƒíƒœ: rtChoices.style.display,
                                    ê³„ì‚°ëœí‘œì‹œ: computedStyle2.display,
                                    ë†’ì´: rtChoices.offsetHeight
                                });
                                
                                if (checkButtons2.length > 0 && rtChoices.offsetHeight === 0) {
                                    console.warn('âš ï¸ Player2 ë²„íŠ¼ì´ ìˆì§€ë§Œ ë†’ì´ê°€ 0, ê°•ì œ í‘œì‹œ');
                                    forceShowButtons();
                                    attachChoiceListeners();
                                }
                                
                                // Player2 ìµœì¢… í™•ì¸ ë° ê°•ì œ í‘œì‹œ
                                if (!amPlayer1) {
                                    const finalComputed = window.getComputedStyle(rtChoices);
                                    if (finalComputed.display !== 'flex' || rtChoices.offsetHeight === 0) {
                                        console.warn('âš ï¸ Player2 ìµœì¢… í™•ì¸ì—ì„œ ë¬¸ì œ ë°œê²¬, ìµœì¢… ê°•ì œ í‘œì‹œ');
                                        forceShowButtons();
                                        attachChoiceListeners();
                                    }
                                }
                            }
                        }, 800);
                    }
                }
            }

            // Player2ë¥¼ ìœ„í•´ ì¦‰ì‹œ ë²„íŠ¼ í‘œì‹œ ì‹œë„ (ë°ì´í„° ë¡œë“œ ì „)
            if (!amPlayer1) {
                console.log('ğŸš€ Player2 ì¦‰ì‹œ ë²„íŠ¼ í‘œì‹œ ì‹œë„');
                
                // Player2 í´ë˜ìŠ¤ ì¶”ê°€
                const choicesEl = document.getElementById('rtChoices');
                if (choicesEl) {
                    choicesEl.classList.add('player2-active');
                }
                
                setTimeout(() => {
                    forceShowButtons();
                }, 100);
                
                // MutationObserverë¡œ ë²„íŠ¼ì´ ìˆ¨ê²¨ì§€ë©´ ì¦‰ì‹œ ë‹¤ì‹œ í‘œì‹œ
                if (choicesEl) {
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                                const target = mutation.target;
                                const computedStyle = window.getComputedStyle(target);
                                if (target.id === 'rtChoices' && computedStyle.display === 'none') {
                                    console.warn('âš ï¸ Player2 MutationObserver: ë²„íŠ¼ì´ ìˆ¨ê²¨ì§ ê°ì§€, ì¦‰ì‹œ í‘œì‹œ');
                                    forceShowButtons();
                                }
                            }
                            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                                const target = mutation.target;
                                if (target.id === 'rtChoices' && !target.classList.contains('player2-active')) {
                                    console.warn('âš ï¸ Player2 MutationObserver: player2-active í´ë˜ìŠ¤ ì œê±° ê°ì§€, ë‹¤ì‹œ ì¶”ê°€');
                                    target.classList.add('player2-active');
                                    forceShowButtons();
                                }
                            }
                        });
                    });
                    
                    observer.observe(choicesEl, {
                        attributes: true,
                        attributeFilter: ['style', 'class'],
                        childList: false,
                        subtree: false
                    });
                    
                    console.log('âœ… Player2 MutationObserver ì‹œì‘');
                }
                
                // Player2ë¥¼ ìœ„í•œ ì§€ì†ì ì¸ ë²„íŠ¼ í™•ì¸ í´ë§ (ë§¤ 300msë§ˆë‹¤ - ë” ìì£¼ í™•ì¸)
                const player2ButtonPoll = setInterval(() => {
                    const choicesEl = document.getElementById('rtChoices');
                    if (!choicesEl) {
                        clearInterval(player2ButtonPoll);
                        return;
                    }
                    
                    const buttons = choicesEl.querySelectorAll('.rt-choice');
                    const computedStyle = window.getComputedStyle(choicesEl);
                    const isVisible = computedStyle.display === 'flex' && choicesEl.offsetHeight > 0;
                    
                    if (buttons.length > 0 && !isVisible) {
                        console.warn('âš ï¸ Player2 í´ë§: ë²„íŠ¼ì´ ìˆ¨ê²¨ì ¸ ìˆìŒ, ê°•ì œ í‘œì‹œ');
                        choicesEl.classList.add('player2-active');
                        forceShowButtons();
                        attachChoiceListeners();
                    }
                    
                    // player2-active í´ë˜ìŠ¤ê°€ ì—†ìœ¼ë©´ ì¶”ê°€
                    if (!choicesEl.classList.contains('player2-active')) {
                        choicesEl.classList.add('player2-active');
                        forceShowButtons();
                    }
                    
                    // ê²Œì„ì´ ëë‚¬ê±°ë‚˜ ë°©ì„ ë‚˜ê°”ìœ¼ë©´ í´ë§ ì¤‘ì§€
                    if (realtimeRoomId !== roomId) {
                        console.log('ğŸ›‘ Player2 í´ë§ ì¤‘ì§€ (ë°© ë³€ê²½)');
                        clearInterval(player2ButtonPoll);
                    }
                }, 300);
                
                // 15ì´ˆ í›„ í´ë§ ì¤‘ì§€ (ë” ì˜¤ë˜ ì‹¤í–‰)
                setTimeout(() => {
                    clearInterval(player2ButtonPoll);
                    console.log('ğŸ›‘ Player2 í´ë§ ì¤‘ì§€ (íƒ€ì„ì•„ì›ƒ)');
                }, 15000);
            }
            
            // ë°© ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ì„œ ì´ˆê¸° ë Œë”ë§ (Player1ê³¼ Player2 ëª¨ë‘ ë™ì¼í•˜ê²Œ ì²˜ë¦¬)
            console.log(`ğŸ“¥ ${amPlayer1 ? 'Player1' : 'Player2'} ë°© ë°ì´í„° ë¡œë“œ ì‹œì‘...`);
            supabase.from('rooms').select('*').eq('id', roomId).single().then(({ data, error }) => { 
                if (error) {
                    console.error(`âŒ ${amPlayer1 ? 'Player1' : 'Player2'} ë°© ë°ì´í„° ì¡°íšŒ ì˜¤ë¥˜:`, error);
                    document.getElementById('realtimeStatus').textContent = 'ìƒëŒ€ë°©ì„ ì°¾ëŠ” ì¤‘...';
                    document.getElementById('rtChoices').style.display = 'none';
                    return;
                }
                
                if (data) {
                    console.log(`ğŸ“¦ ${amPlayer1 ? 'Player1' : 'Player2'} ë°© ë°ì´í„° ë¡œë“œ ì™„ë£Œ:`, data);
                    console.log('ğŸ” ë²„íŠ¼ í‘œì‹œ ì „ rtChoices ìƒíƒœ:', {
                        display: rtChoices.style.display,
                        visibility: rtChoices.style.visibility,
                        buttons: rtChoices.querySelectorAll('.rt-choice').length,
                        offsetHeight: rtChoices.offsetHeight,
                        player: amPlayer1 ? 'Player1' : 'Player2'
                    });
                    
                    // renderRoom í˜¸ì¶œ
                    renderRoom(data);
                    
                    // Player2ë¥¼ ìœ„í•´ ì¦‰ì‹œ ë²„íŠ¼ ê°•ì œ í‘œì‹œ
                    if (!amPlayer1) {
                        forceShowButtons();
                    }
                    
                    console.log(`ğŸ” ${amPlayer1 ? 'Player1' : 'Player2'} ë²„íŠ¼ í‘œì‹œ í›„ rtChoices ìƒíƒœ:`, {
                        display: rtChoices.style.display,
                        visibility: rtChoices.style.visibility,
                        buttons: rtChoices.querySelectorAll('.rt-choice').length,
                        offsetHeight: rtChoices.offsetHeight,
                        computedDisplay: window.getComputedStyle(rtChoices).display,
                        computedVisibility: window.getComputedStyle(rtChoices).visibility
                    });
                    
                    // renderRoom í›„ì— ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë‹¤ì‹œ ì—°ê²° (Player2ë¥¼ ìœ„í•´ ë” í™•ì‹¤í•˜ê²Œ)
                    setTimeout(() => {
                        console.log(`ğŸ”— ${amPlayer1 ? 'Player1' : 'Player2'} renderRoom í›„ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¬ì—°ê²°`);
                        
                        // Player2ë¥¼ ìœ„í•´ ë²„íŠ¼ ë‹¤ì‹œ ê°•ì œ í‘œì‹œ
                        if (!amPlayer1) {
                            forceShowButtons();
                        }
                        
                        attachChoiceListeners();
                        
                        // ë²„íŠ¼ì´ ì •ë§ ë³´ì´ëŠ”ì§€ ìµœì¢… í™•ì¸ (Player2 íŠ¹ë³„ í™•ì¸)
                        const finalCheck = rtChoices.querySelectorAll('.rt-choice');
                        const computedStyle = window.getComputedStyle(rtChoices);
                        console.log(`âœ… ${amPlayer1 ? 'Player1' : 'Player2'} ìµœì¢… í™•ì¸:`, {
                            ë²„íŠ¼ê°œìˆ˜: finalCheck.length,
                            í‘œì‹œìƒíƒœ: rtChoices.style.display,
                            ê³„ì‚°ëœí‘œì‹œ: computedStyle.display,
                            ê³„ì‚°ëœê°€ì‹œì„±: computedStyle.visibility,
                            ë†’ì´: rtChoices.offsetHeight,
                            ë„ˆë¹„: rtChoices.offsetWidth,
                            opacity: computedStyle.opacity
                        });
                        
                        if (finalCheck.length === 0) {
                            console.error(`âŒ ${amPlayer1 ? 'Player1' : 'Player2'} ë²„íŠ¼ì´ ì—†ìŠµë‹ˆë‹¤!`);
                        }
                        if (rtChoices.offsetHeight === 0 || computedStyle.display === 'none') {
                            console.warn(`âš ï¸ ${amPlayer1 ? 'Player1' : 'Player2'} ë²„íŠ¼ ì»¨í…Œì´ë„ˆê°€ ìˆ¨ê²¨ì ¸ ìˆìŠµë‹ˆë‹¤! ê°•ì œ í‘œì‹œ ì‹œë„`);
                            forceShowButtons();
                            
                            // ë‹¤ì‹œ í•œ ë²ˆ í™•ì¸
                            setTimeout(() => {
                                const recheck = rtChoices.querySelectorAll('.rt-choice');
                                console.log(`ğŸ”„ ${amPlayer1 ? 'Player1' : 'Player2'} ì¬í™•ì¸:`, {
                                    ë²„íŠ¼ê°œìˆ˜: recheck.length,
                                    ë†’ì´: rtChoices.offsetHeight,
                                    í‘œì‹œ: window.getComputedStyle(rtChoices).display
                                });
                                if (recheck.length > 0 && rtChoices.offsetHeight > 0) {
                                    attachChoiceListeners();
                                } else if (!amPlayer1) {
                                    // Player2ì˜ ê²½ìš° ë” ì ê·¹ì ìœ¼ë¡œ
                                    console.warn('âš ï¸ Player2 ë²„íŠ¼ì´ ì—¬ì „íˆ ì•ˆ ë³´ì„, ìµœì¢… ê°•ì œ í‘œì‹œ');
                                    forceShowButtons();
                                    attachChoiceListeners();
                                }
                            }, 300);
                        }
                    }, 500);
                    
                    // Player2ë¥¼ ìœ„í•´ ì¶”ê°€ í™•ì¸ (1ì´ˆ í›„)
                    if (!amPlayer1) {
                        setTimeout(() => {
                            const player2Check = rtChoices.querySelectorAll('.rt-choice');
                            const player2Computed = window.getComputedStyle(rtChoices);
                            console.log('ğŸ” Player2 ì¶”ê°€ í™•ì¸ (1ì´ˆ í›„):', {
                                ë²„íŠ¼ê°œìˆ˜: player2Check.length,
                                í‘œì‹œ: player2Computed.display,
                                ë†’ì´: rtChoices.offsetHeight
                            });
                            if (player2Computed.display !== 'flex' || rtChoices.offsetHeight === 0) {
                                console.warn('âš ï¸ Player2 ë²„íŠ¼ ë¬¸ì œ ê°ì§€, ìµœì¢… ìˆ˜ì • ì‹œë„');
                                forceShowButtons();
                                attachChoiceListeners();
                            }
                        }, 1000);
                    }

                    // ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ë¥¼ ë†“ì³ë„ UIê°€ ë³´ì´ë„ë¡ ë°© ìƒíƒœ ì¬í™•ì¸ (ìµœëŒ€ 8ì´ˆ)
                    if (realtimeRenderRetryTimer) clearInterval(realtimeRenderRetryTimer);
                    const retryStart = Date.now();
                    realtimeRenderRetryTimer = setInterval(async () => {
                        if (realtimeRoomId !== roomId) {
                            clearInterval(realtimeRenderRetryTimer);
                            realtimeRenderRetryTimer = null;
                            return;
                        }
                        if (Date.now() - retryStart > 8000) {
                            clearInterval(realtimeRenderRetryTimer);
                            realtimeRenderRetryTimer = null;
                            return;
                        }
                        const { data: latestRoom } = await supabase.from('rooms').select('*').eq('id', roomId).single();
                        if (latestRoom) {
                            renderRoom(latestRoom);
                            if (window.getComputedStyle(rtChoices).display === 'flex' && rtChoices.offsetHeight > 0) {
                                clearInterval(realtimeRenderRetryTimer);
                                realtimeRenderRetryTimer = null;
                            }
                        }
                    }, 500);
                } else {
                    console.error(`âŒ ${amPlayer1 ? 'Player1' : 'Player2'} ë°© ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:`, roomId);
                    document.getElementById('realtimeStatus').textContent = 'ìƒëŒ€ë°©ì„ ì°¾ëŠ” ì¤‘...';
                    document.getElementById('rtChoices').style.display = 'none';
                }
            }).catch(error => {
                console.error(`âŒ ${amPlayer1 ? 'Player1' : 'Player2'} ë°© ë°ì´í„° ë¡œë“œ ì¤‘ ì˜¤ë¥˜:`, error);
            });

            async function applyScoreIfBothChose(room) {
                if (!room || room.status !== 'playing' || !room.p1_choice || !room.p2_choice || !amPlayer1) return;
                const res = computeResult(room.p1_choice, room.p2_choice);
                let ns1 = room.p1_score || 0, ns2 = room.p2_score || 0;
                if (res === 'draw') {
                    await supabase.from('rooms').update({
                        p1_choice: null,
                        p2_choice: null,
                        status: 'playing'
                    }).eq('id', roomId);
                    return;
                }

                if (res === 'win') ns1++; else if (res === 'lose') ns2++;
                await supabase.from('rooms').update({
                    p1_score: ns1,
                    p2_score: ns2,
                    status: 'done'
                }).eq('id', roomId);
            }

            const chRoom = supabase.channel('room_' + roomId.replace(/-/g, '_')).on('postgres_changes', { event: '*', schema: 'public', table: 'rooms', filter: 'id=eq.' + roomId }, async (payload) => {
                if (payload.new) {
                    console.log(`ğŸ”„ ${amPlayer1 ? 'Player1' : 'Player2'} ë°© ìƒíƒœ ë³€ê²½ ê°ì§€:`, payload.new);
                    
                    // Player2ë¥¼ ìœ„í•´ ë²„íŠ¼ ê°•ì œ í‘œì‹œ (renderRoom ì „ì—)
                    if (!amPlayer1) {
                        rtChoices.classList.add('player2-active');
                        forceShowButtons();
                    }
                    
                    renderRoom(payload.new);
                    await applyScoreIfBothChose(payload.new);
                    
                    // Player2ë¥¼ ìœ„í•´ ë²„íŠ¼ ê°•ì œ í‘œì‹œ (renderRoom í›„ì—ë„)
                    if (!amPlayer1) {
                        setTimeout(() => {
                            rtChoices.classList.add('player2-active');
                            forceShowButtons();
                        }, 100);
                    }
                    
                    // renderRoom í›„ì— ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ í™•ì¸ ë° ì¬ì—°ê²° (Player2ë¥¼ ìœ„í•´ ë” í™•ì‹¤í•˜ê²Œ)
                    setTimeout(() => {
                        const buttons = rtChoices.querySelectorAll('.rt-choice');
                        const hasDisabledButtons = Array.from(buttons).some(btn => btn.disabled);
                        const computedDisplay = window.getComputedStyle(rtChoices).display;
                        const hasVisibleButtons = rtChoices.style.display === 'flex' || computedDisplay === 'flex';
                        
                        console.log(`ğŸ” ${amPlayer1 ? 'Player1' : 'Player2'} ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ í™•ì¸:`, {
                            ë²„íŠ¼ê°œìˆ˜: buttons.length,
                            ë¹„í™œì„±í™”ë²„íŠ¼ìˆìŒ: hasDisabledButtons,
                            í‘œì‹œë¨: hasVisibleButtons,
                            ê³„ì‚°ëœí‘œì‹œ: computedDisplay
                        });
                        
                        // Player2ì˜ ê²½ìš° ë” ì ê·¹ì ìœ¼ë¡œ ì¬ì—°ê²°
                        if (hasVisibleButtons) {
                            if (!hasDisabledButtons || !amPlayer1) {
                                console.log(`ğŸ”— ${amPlayer1 ? 'Player1' : 'Player2'} ë²„íŠ¼ì´ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¬ì—°ê²°`);
                                attachChoiceListeners();
                            }
                        } else {
                            console.warn(`âš ï¸ ${amPlayer1 ? 'Player1' : 'Player2'} ë²„íŠ¼ì´ í‘œì‹œë˜ì§€ ì•ŠìŒ, ê°•ì œ í‘œì‹œ ì‹œë„`);
                            forceShowButtons();
                            setTimeout(() => {
                                attachChoiceListeners();
                                // Player2ì˜ ê²½ìš° í•œ ë²ˆ ë” í™•ì¸
                                if (!amPlayer1) {
                                    forceShowButtons();
                                }
                            }, 100);
                        }
                    }, 200);
                }
            });
            chRoom.subscribe();
            realtimeUnsub.push(chRoom);

            // ì„ íƒ ë²„íŠ¼ì— ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì—°ê²° í•¨ìˆ˜
            function attachChoiceListeners() {
                if (rtChoices.dataset.listenerAttached === 'true') return;
                rtChoices.dataset.listenerAttached = 'true';
                console.log('ğŸ”— ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ(ìœ„ì„) ì—°ê²° ì™„ë£Œ');

                rtChoices.addEventListener('click', async function(e) {
                    const btn = e.target.closest('.rt-choice');
                    if (!btn || !rtChoices.contains(btn)) return;
                    e.preventDefault();
                    e.stopPropagation();

                    if (btn.disabled || btn.hasAttribute('disabled')) {
                        console.log('â¸ï¸ ì´ë¯¸ ì„ íƒí•œ ë²„íŠ¼ì…ë‹ˆë‹¤.');
                        return;
                    }

                    const choice = btn.dataset.choice;
                    console.log('âœ… ë²„íŠ¼ í´ë¦­! ì„ íƒ:', choice, 'Player', amPlayer1 ? '1' : '2', 'Room:', roomId);
                    const encodedChoice = encodeChoice(choice);

                    // ëª¨ë“  ë²„íŠ¼ ì¦‰ì‹œ ë¹„í™œì„±í™” (ì¤‘ë³µ ì„ íƒ ë°©ì§€)
                    rtChoices.querySelectorAll('.rt-choice').forEach(b => {
                        b.disabled = true;
                        b.setAttribute('disabled', 'disabled');
                        b.style.opacity = '0.5';
                        b.style.cursor = 'not-allowed';
                        b.style.pointerEvents = 'none';
                    });

                    try {
                        if (amPlayer1) {
                            const { error } = await supabase.from('rooms').update({ p1_choice: encodedChoice }).eq('id', roomId);
                            if (error) throw error;
                            console.log('âœ… Player1 ì„ íƒ ì „ì†¡ ì™„ë£Œ:', choice);
                        } else {
                            const { error } = await supabase.from('rooms').update({ p2_choice: encodedChoice }).eq('id', roomId);
                            if (error) throw error;
                            console.log('âœ… Player2 ì„ íƒ ì „ì†¡ ì™„ë£Œ:', choice);
                        }

                        // ìº¡ìŠì— ë‹´ëŠ” ëŠë‚Œ(ë´‰ì¸ + íŒ)
                        if (capsuleArea) capsuleArea.style.display = 'flex';
                        setCapsuleState(myCapsule, false, 'ğŸ’Š');
                        popCapsule(myCapsule);

                        // ê²°ê³¼ í™•ì¸ ë° ì ìˆ˜ ì—…ë°ì´íŠ¸
                        const { data: room, error: roomError } = await supabase.from('rooms').select('*').eq('id', roomId).single();
                        if (roomError) throw roomError;

                        if (room && room.p1_choice && room.p2_choice && amPlayer1) {
                            const res = computeResult(room.p1_choice, room.p2_choice);
                            let ns1 = room.p1_score || 0, ns2 = room.p2_score || 0;
                            if (res === 'win') ns1++;
                            else if (res === 'lose') ns2++;

                            const { error: updateError } = await supabase.from('rooms').update({
                                p1_score: ns1,
                                p2_score: ns2,
                                status: 'done'
                            }).eq('id', roomId);
                            if (updateError) throw updateError;
                            console.log('âœ… ì ìˆ˜ ì—…ë°ì´íŠ¸ ì™„ë£Œ:', { p1_score: ns1, p2_score: ns2 });
                        }
                    } catch (error) {
                        console.error('âŒ ì„ íƒ ì „ì†¡ ì˜¤ë¥˜:', error);
                        // ì˜¤ë¥˜ ë°œìƒ ì‹œ ë²„íŠ¼ ë‹¤ì‹œ í™œì„±í™”
                        rtChoices.querySelectorAll('.rt-choice').forEach(b => {
                            b.disabled = false;
                            b.removeAttribute('disabled');
                            b.style.opacity = '1';
                            b.style.cursor = 'pointer';
                            b.style.pointerEvents = 'auto';
                        });
                    }
                });
            }
            
            // ì¦‰ì‹œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì—°ê²° (ì´ˆê¸° ì„¤ì •)
            setTimeout(() => {
                attachChoiceListeners();
            }, 100);
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ ì‹œì‘
        if (SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL !== 'YOUR_SUPABASE_URL') {
            startRealtime();
        } else {
            document.getElementById('realtimeStatus').textContent = 'Supabase URL/í‚¤ë¥¼ ì„¤ì •í•´ ì£¼ì„¸ìš”. (destiny.html ìƒë‹¨)';
        }
    </script>
</body>
</html>
